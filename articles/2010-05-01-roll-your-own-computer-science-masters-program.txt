--- 
title: Roll Your Own Computer Science Masters Program
date: 01/05/2010

Struck by some sort of errant whim to get more edumacated, I started googling Computer Science Master's Degree programs today. Actually, I did one google search and then jumped straight to the [University of St. Thomas](http://www.stthomas.edu/gradsoftware/programs/ms/default.html) page on graduate programs in software. Did a little back of the envelope thinking, noted that St. Thomas wants $762.50 per credit, and decided against a Masters degree at this point in time.

But it did get me thinking. Why would I _want_ a Masters Degree, anyways? All the reasons I could think of boiled down to these two:

1. I want to go into a role, career, or position that _requires_ a Masters Degree.
2. I want to go into a role, career, or position that requires the _knowledge_ presumably attained from a Masters Degree.

This is a pretty important distinction. Some roles might simply have a Masters as a _requirement_. Doesn't actually mean they care if you _know_ anything. Yes, of course, they assume that you do, and that your Masters actually means something, but really, for this type of thing, all that's important is the piece of paper.

And the truth is, I'm not really interested in any of those roles. Off the top of my head, all I could come up with in that category would be roles in a Fortune 500 or similarly credential-obsessed enterprise, or a role at a University, neither of which is something I want to pursue.

On the other hand, maybe I just want to _know_ the information I might learn in a Masters program. Or maybe I have my sights on a career that really requires the _knowledge_, but doesn't necessarily care if I have the piece of paper or not. That sort of role might include (again, off the top of my head), the technical founder or lead in a startup, a writer or speaker about tech topics, or simply a kick-ass software developer who knows more this year than he did last year. Now _those_ sorts of things are interesting.

All of which means it doesn't really matter if I go to a University.

Continuing on with this line of thought, I started mulling over the knowledge I've accumulated so far. How much would I attribute to college education, and how much did I teach myself? It's a little hard to quantify, because there's a lot of overlap, but even allowing some margin of error, the topics which I've taught myself have been far more useful/valuable than those I learned in my undergraduate degree (which was in Computer Science).

More importantly, and maybe more telling, I have a far better grasp on the things that I've taught myself than I do on many of the things I "had" to learn in college. I know Ruby and Rails far better than I know Java, and I've had _at least_ four or five college courses dedicated to Java (most of which, _even the 4th year course in Operating Systems_, assumed we didn't know anything about Java or OOP and re-taught it all over again).

I'm going to make a suggestion as to why this might be. I'm going to suggest that when we're teaching something to ourselves, we hold ourselves to a higher standard than the average college course holds us.

In an average college class, all that really matters is:

1. Attendance (as crazy as it sounds, evidently they actually still care if you attend class, for reasons unfathomable to me).
2. Making an average effort to skim the material.
3. Making an average effort to complete assignments (often can combine with #2, as usually the only material you ever need to read is whatever is pertinent to the assignment).
4. Remembering _just enough_ information for _just long enough_ to have an adequate number of correct answers on your exams.

(Aside: the possible exception to this is Calculus and other advanced math classes, unless you are one of those people who absorb that with a minimum of effort; you either understand Calculus (et. al.), or you don't, you can't really just push your way through those one. YMMV.)

When you're teaching _yourself_, on the other hand:

1. While you _are_ working at your own pace, chances are you actually want to _use_ the information or ideas that you're learning, so you don't want it to take forever. You may or may not have a fixed deadline in mind, but regardless, you are motivated to make progress for it's own sake, not simply to get to the end of a semester.
2. You can't fake yourself out. You can't tell yourself that you know something when you know you don't. You won't fool yourself into thinking that you understand lambdas, or ruby blocks, or closures, or monads, or red-black trees, or any data structure or algorithm, if you _know_ that you don't. So if it matters to you that you learn it, you just have to keep going back until you get it.
3. Again, you have some reason that you actually _want to use_ this information. It's not solely to check of a list (e.g., Okay, I have memorized a bunch of ideas about Design Patterns, check), but it's because you want to _do_ something with the knowledge once you have it (e.g., Okay, I've learned some design patterns. Am I using any of these in my software side projects? If I did use one, would it improve my application? Can I identify these patterns if I see them in the wild? Etc.)
4. Not only can you not fake yourself out, you probably underestimate yourself. When you're teaching yourself, your often painfully aware of how much you still _don't_ know, how much you still have left to learn, and it frequently blinds you to how much you've actually learned so far. Why is this good? Well, eventually you do need to recognize your progress and give yourself a pat or two on the back, but in general I think it's good because it means you'll push yourself harder to learn more. A good way to gauge your progress is to join a forum, a StackOverflow-type site, or an IRC chat room in the area you're studying, and look at the questions people are asking. Chances are you're going to find that a lot of people are asking questions that you (gasp) already know the answers to (now would be a nice time to help them, if you have time). That's a good sign.

Now, self-discipline, which I didn't mention, may or may not be an issue. An oft-mentioned advantage of college or course-work in general is that it pushes you to learn faster because of the built in deadlines, exams and assignments. The problem is, as I argued above, that yes, it may push you to accomplish specific milestones, but all too often this means you are _pushed to accomplish the bare minimum with the least effort at the last minute_. 

And don't tell me that means I'm just "not a very good student", then. Sure, if you can combine powerful self-motivation with college coursework, you can get more than the "minimum" amount of education from a class, and some students do. So have I, in some courses. 

But for better or worse, I've found that in many courses the combination of arbitrary requirements (i.e., the need to be present in class), _horrible_ textbooks, frequently unenthusiastic professors (sorry guys; to be _interesting_ you have to _be interested_ in what you're talking about), and a highly subjective qualification for success (complete these _n_ assignments and learn these _n_ concepts well enough to pass an exam or two), means that the very structure and implementation of a college class encourages you to do _just enough to get by and no more_, period.

(Aside: on horrible textbooks: the only textbooks I've wanted to keep from my entire time obtaining a computer science degree have been Sipser's <cite>[Introduction to the Theory of Computation](http://www.amazon.com/gp/product/0534950973?ie=UTF8&tag=idepermin-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0534950973)</cite> and Larman's <cite>[Applying UML and Patterns](http://www.amazon.com/gp/product/0131489062?ie=UTF8&tag=idepermin-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0131489062)</cite>; and of those, I gotta say, the Larman book is pretty boring (sorry, Craig, maybe we can blame your editors), but there's some good material in there.)

So, enough complaining about colleges. I don't really have any suggestions for how to fix the education system, if indeed it is broken -- I'll leave it to others to debate and solve that problem. But since I'm convinced that self-learning is more productive and more effective, then if I'm interested in the information that I might learn in a Masters Program in Computer Science, it seems reasonable that I'd be better off concocting my own program and just starting to plug away.

At the top of this article I put a link to the University of St. Thomas' graduate program in Software Engineering. Suppose we take that as a model and make a plan.

Required courses we have:

1. Foundations of Software Development. It's waivable with experience, and if you're even reading or contemplating doing something remotely like this, I'm going to guess you and I can waive this one. We're assuming you can already code your way out of a paper bag, people. If you can't do the [FizzBuzz problem](http://www.codinghorror.com/blog/2007/02/why-cant-programmers-program.html) or [write a binary search given the description](http://reprog.wordpress.com/2010/04/19/are-you-one-of-the-10-percent/), then you can't waive this. Get up to speed, folks.

2. Technical Communication. Writing and speaking. I can see it being useful, but you're going to have to decide if it something you want to be good at it. If it is:
    * Write a technical blog. Force yourself to do it semi-regularly. Explain a concept, how you solved a problem, why something is the way it is, etc. You're not doing it to become a ProBloggerSuperStar, you're doing it to improve your written communication skills.
    * Find & join a local users group in your field of interest (say, Ruby, Java, Cocoa, whatever) and give a presentation. At least one, to start. In anything. If this is something you want to be a lot better at, try to think of several presentations you could give; then volunteer to give them.

3. Software Engineering. Read (or re-read) <cite>[Code Complete](http://www.amazon.com/gp/product/0735619670?ie=UTF8&tag=idepermin-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0735619670)</cite>. The St. Thomas course description also includes the idea of estimating, so Mike Cohn's <cite>[Agile Estimating And Planning](http://www.amazon.com/gp/product/0131479415?ie=UTF8&tag=idepermin-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0131479415)</cite> might also be apropos. If you've read both of those, then scan them to make sure you're still up to speed and either a) give yourself a pass, you've got this one, or b) re-read or pick an alternate/more advanced tome on the subject and plow through it.

4. Database Management Systems And Design. I'm assuming you already know and use regularly at least one or more DB system; probably MySQL, but possibly sqlite, Postgres, or even MS SQL Server or Oracle. Great. Maybe you even know CouchDB or MongoDB or some other NoSQL system. Well, this is a Masters program. That's Not Good Enough.
    - Give yourself a refresher in DB design, SQL, maybe relational algebra if you like that sort of thing. _Database in Depth_ is a good book. You might know others.
    - Learn another system, whatever seems most useful to what you are doing (remember a HUGE key in making this work is that it must be something you really want to know about; follow what interests you): maybe a NoSQL db, or maybe Postgres. Learn what makes this DB different from others, from what you know already, and why. Try to figure out real reasons and/or scenarios you'd want to use one or the other.
    
5. OOAAD (Object Oriented Application Analysis and Design). Well you could read [Larman](http://www.amazon.com/gp/product/0131489062?ie=UTF8&tag=idepermin-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0131489062) or Booch, and that's probably not a bad idea. Try to make it applicable to things you want to work on, as always.

6. Software Project Management. This is an area I could probably stand to improve in; I'm not certain, but I think I'd start with one or more of Scott Berkun's books ([The Art of Project Management](http://www.amazon.com/gp/product/0596007868?ie=UTF8&tag=idepermin-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0596007868), [Making Things Happen](http://www.amazon.com/gp/product/0596517718?ie=UTF8&tag=idepermin-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0596517718)) on the topic, which seem to have attained a sort of Gold Standard status. If you're certification-minded you might reach for a PMP-based book. I'm not gung-ho on certifications, but maybe you think it will be good to have; and honestly, of all the certs out there, this one seems the most useful. If you have experience with PMP pro or con that you'd like to leave in the comments, please do, but remember that the whole point of this plan is to be more interested in _results_ than _whether or not my certification can get me a job with SAP_.

7. Software Quality Assurance. This would be the ideal place to learn even more about software testing. Aside from that, I would have to look for some specific material pertinent to Software QA; suggestions welcome.

8. Operating Systems. Yeah, I guess it's useful. And maybe it's super-interesting to you; at the moment it's not an area of intense interest to me, but I can see its applicability. I'd probably start by identifying the areas in which this sort of knowledge will help the most; probably in the areas of processes, threads, memory management and related themes. Might want to brush out the old C programming toolset and pick up a book on the Linux kernel; I don't know. Again, if the only point is to check another item off the checklist, it probably will be hell to learn and you might not even bother. So find a way to make it interesting. Maybe just spend awhile really learning or re-learning multi-threaded application programming.

9. Computer and Network Communications. Again, I'm guessing we have the foundations of _at least_ some or much of this down. So find an area of interest to you and push your knowledge further. Learn [Node.js](http://nodejs.org) and write a server. Find an Open Source server/networking project and attempt to contribute something to it (even if it's just documentation; come to think of it, contributing to a related OSS project would be a fantastic progress gauge for every area on this list.)

10. 5+ electives. There's always more to learn; what are you most interested in?
    - Applied Statistics/Machine Learning/Analysis
    - Other Maths? Go nuts.
    - Another programming language. Lisp, Erlang, Python, Ruby, C(++/#), Objective-C/Cocoa, Javascript... pick something that you don't know that you'd _like_ to know, and start knowing it. Since one of the major hurdles in learning a new language is the "what the heck should I write in this language?" problem, a good tactic might be to apply your new language to one of the above subject areas; do your DB, Networking, or QA/testing explorations in a language other than the ones you already know.
    - Security. Big topic.
    - Cryptography. Related to security, but also a big topic all on its own.
    - Algorithms and Data Structures. We all probably have some exposure to these, but if it's an area of interest to you, I'm betting you'll always learn something from a refresher course.
    - Data Warehousing/Mining/etc.
    - Distributed Databases or servers.
    - Real Time systems/concepts.
    - Artificial Intelligence, related research.
    - .... ? I don't know, you pick something you're interested in.
  
There's some of the above I feel like I have a decent grasp of, there's some that I don't. There's some things that interest me, and that applies directly to the ways I pay the bills each month, so obviously those are the things I'd probably gravitate towards learning first.

I'm not going to "log my progress" on following this or any similar plan, but my point is:

- It's doable.
- It's valuable in and of itself.
- You don't need to spend 20K+ at a university to do it.
- If/when you really have a grasp of all (or even MOST) of the above, you're a software engineer who really knows his/her stuff, and especially if you can show the Open Source or other projects that you've contributed to along the way... you really don't need the piece of paper from the university.

If you don't like my list, or the books/ideas I've listed, make your own. Or, you know, whatever. I think most really good developers plan to keep learning continuously anyways, and are probably already doing so; this just happens to be a little more structured list based off a given Masters program description. Part of my whole theory here is that you're going to be more successful if you're trying to learn things that really interest you, or that you really want to use, so if you don't _care_ about project management, or networking, or databases, then by all means, just _skip it_. Focus on what you want to know. Maybe you'd rather jump straight in to statistics and machine learning. Go download _[R](http://www.r-project.org/)_ and have a ball.

Comments, suggestions, hate mail, fan fiction, can be submitted below. Thanks for reading.