--- 
title: Ruby's Object#send Can Call Private And Protected Methods
date: 26/06/2009

<a href="http://www.flickr.com/photos/xiaming/99206245/"><img src="http://farm1.static.flickr.com/30/99206245_862bc5c93d.jpg?v=0" /></a>
<small>Photo by <a href="http://www.flickr.com/photos/xiaming/99206245/">xiaming</a></small>

One of the hallmarks of object oriented programming in most every implementation of it that I know of is the ability to designate certain methods as "private" or "protected", thus keeping them from being called willy-nilly by any old script that wants to call them. Ruby also has this, of course, but interestingly enough it can be easily circumvented.

I guess there are a few posts floating around about it, but I discovered it by accident playing around in irb this evening. I was reading David A. Black's The Well Grounded Rubyist, where he mentions that you could send a message to a class either within the class definition itself, or by simply sending it to the class object like you'd send any other message:

<pre>
<code class="ruby">
# The normal way to do it
class Thing
  message :whatever
end

# you could also do this
Thing.message(:whatever)
</code>
</pre>
<!--more-->
David mention's attr_accessor in this context, so I thought I'd try that. Open <code>irb</code>:

<pre lang="ruby">
>> class Thing
?> end
>> Thing.attr_accessor :name
NoMethodError: private method 'attr_accessor' called for Thing:Class
</pre>

Oh. So much for that, then. But, knowing of the existence of the send method, I thought I'd try that.

<pre lang="ruby">
Thing.send(:attr_accessor, :name)
=> nil
</pre>

For the non-<code>irb</code> user, that <code>nil</code> that was returned, and the fact that no error message was returned, indicated that our experiment worked. Now <code>Thing</code>'s have a name attribute.

<pre lang="ruby">
>> t = Thing.new
>> t.name = "Larry"
=> "Larry"
>> t.name
=> "Larry"
</pre>

What's interesting about all this is that <code>attr_accessor</code> is a private method on <code>Class</code>. Yet we just called it.

<code>send</code> is often introduced as a way to show how everything is an object and that you can do exciting things like <code>1.send(:+, 1)</code> and get <code>2</code> as the result. No one usually mentions that it can be used to call private or protected methods from outside a given class.

To make it clear what you could do here:

<pre lang="ruby">
>> class Thing
?>    def hello
?>     puts "Hello, world!"
?>   end
?>   private
?>     def private_hello
?>       puts "Hello, privately."
?>     end
?> end
>> t = Thing.new
>> t.hello
Hello, world!
=> nil
>> t.private_hello
NoMethodError: private method 'private_hello' called for ...
>> t.send(:private_hello)
Hello, privately.
=> nil
</pre>

So, yes. You can do this, if you so choose. Please use your powers for good, and not for evil.

Now <em>why</em> this works, I can't yet say, though I'm interested in learning, if there is a reason. Evidently there <a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/7404">may have been some debate</a> as to whether ruby 1.9 would still have this behavior, but as of this writing it does. 

Note: I did only a brief search, and it seems <a href="http://www.google.com/search?client=safari&rls=en-us&q=ruby+send+method&ie=UTF-8&oe=UTF-8">this functionality is not unknown</a>, though it still seems somewhat odd to me that such an easy way to sidestep the private/protected designation of methods exists.